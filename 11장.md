# 11장 원시값과 객체의 비교

js에서 제공하는 7가지의 데이터 타입(숫자, 문자열, 불리언, null, undefined, 심벌, 객체 타입) 은 크게 원시타입과 객체 타입으로 구분한다.

그 이유는 원시타입과 객체 타입이 3가지 측면에서 다르기 때문이다.

- 차이점

  - 1. 원시 타입의 값 즉 원시 값은 변경 불가한 값이다.(immutable) 이에 비해 객체 타입의 값은 변경가능한 값이다.(mutable)

    2. 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체를 변수에 할당하면 참조값이 저장된다.(변수는 확보된 메모리 공간)

    3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다.

       이를 값에 의한 전달이라한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

### 11.1 원시값

#### 11.1.1 변경불가능한 값

원시타입 값은 변경 불가하다. 한번 생성된 원시값은 읽기 전용으로 변경 불가하다.

변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 혹은 그 메모리 공간을 식별하기 위해 붙인 이름

값 : 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과

변경 불가한 것은 변수가 아니라 값이다.

변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있다.

상수는 재할당이 금지된 변수다.

```js
const o = {}; // const 키워드는 변수 재할당 금지됨
// const 키워드를 사용해 선언한 변수에 할당한 원시 값은 변경 불가하지만 const 객체는 변경 가능하다.
o.a = 1;
console.log(o); // {a: 1}
```

원시값을 할당한 변수에 새 원시값을 재할당하면 메모리 공간에 저장되어있는 재할당 이전의 원시값을 변경하는 것이 아니라 새 메모리 공간을 확보하고 재할당한 원시값을 저장후 변수는 새롭게 재할당한 원시값을 가리킨다. 이때 메모리 공간의 주소가 바뀐다.

![image-20220427030507402](/Users/juyoonpark/Desktop/js/STUDY_JS/11장.assets/image-20220427030507402-0996311.png)

원시값은 변경 불가능한 값이다.

메모리 공간의 주소가 변경되는 것을 볼수 있다.

![image-20220427030633943](/Users/juyoonpark/Desktop/js/STUDY_JS/11장.assets/image-20220427030633943.png)

다음처럼 원시값이 변경 가능한 값인 경우에 메모리 공간의 주소를 바꿀 필요없이 원시값 자체를 바꾼다.

만약 그렇다면 변수가 참조하던 메모리 공간의 주소는 바뀌지 않는다.

하지만 원시값은 변경이 불가하기에 직접 값을 변경할 수 없다. 

불변성 : 원시값 재할당 시  -> 새 메모리 공간 확보 -> 재할당한 값 저장 -> 변수가 참조하던 메모리 공간의 주소 변경

불변성 갖는 원시값을 할당한 변수는 재할당 외의 값 변경 방법이 없다. 예기치 않은 변수값이 변경된다는 것은 상태 변경을 추적하기 어렵게 만든다.

#### 11.1.2 문자열과 불변성

원시값인 문자열은 0개 이상의 문자로 이뤄진 집합을 의미하며 1개의 문자는 2바이트의 메모리 공간에 저장된다. 

따라서 문자열은 몇개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다. 숫자 1도 1000000도 동일한 8바이트가 필요하지만 문자열은 1개 -> 2바이트, 10개 -> 20바이트 처럼 다르다.(실제와는 다른 계산)

```js
var str1 = '';
var str2 = 'Hello';
```

이와 같은 이유로 c에는 하나의 문자를 위한 데이터 타입(char)만 존재하고 문자열 타입은 존재하지 않는다.

문자열은 유사 배열 객체이다. 배열처럼 인덱스로 프로퍼티 값에 접근, length프로퍼티를 갖는다.

for 문으로 순회하기도 한다.

문자열의 한 문자를 변경하는 것은 js에서 불가능하다.

그러나 새로운 변수에 문자열을 재할당 하는 것은 당연 가능하다. 기존의 문자열을 변경하는 것이 아닌 새 문자열을 새롭게 할당하는 것이기 때문이다.

#### 11.1.3 값에 의한 전달

```js 
var score = 80;
var copy = score;
// 이처럼 변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달 된다. 이를 값에 의한 전달 이라한다.
console.log(score);// 80
console.log(copy);// 80
console.log(score === copy);// true 둘다 숫자값 80을 갖는다.하지만 변수들의 값 80 은 다른 메모리 공간에 저장된 별개의 값이다.


score = 100;

console.log(score);// 100
console.log(copy);// 80
console.log(score === copy);// false 변수의 값은 다른 메모리 공간에 저장된 별개의 값이라는 것에 주의 하자
// score 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.
```

![image-20220427074334294](/Users/juyoonpark/Desktop/js/STUDY_JS/11장.assets/image-20220427074334294.png)

score 변수의 값을 변경했을 때는

![image-20220427074653612](/Users/juyoonpark/Desktop/js/STUDY_JS/11장.assets/image-20220427074653612.png)

위 그림에선 변수에 원시값을 갖는 